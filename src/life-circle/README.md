
### window onload

可以这么去理解： 
 打开browser一个tab页， 基于WPI 的Window接口创建一个window对象，然后加载文档，window开始逐个加载document上的资料(脚本、样式、图片等所有web资源)，当所有“货物”都执行或加载完毕之后，会触发window.onload方法。 对于动态生成的资源，若在页面加载期间（例如此时正在拉去远端资源图片、脚本啥的），挂载到dom tree上，window也会等到该动态资源加载完成再执行onload事件。 （此处注意，script脚本无论是内置的还是外链的，无论是否声明了异步或是可延迟执行，对window来说都不在乎这些，window不会关心script的加载时机与执行时机；window眼中script的加载单元是这样：“获取脚本-> 执行脚本->执行完毕->脚本加载完毕”。 ）

机制类似： 
 一辆货车按着货物清单(直接声明在document上的资源)装载获取获取，但是装载期间，因计划临时变动需要额外加载了另外一些货物，那么货车也会将这批获取加载，等所有货物都加载了，才能说货车加载完毕了。 如若加载期间，不间断地有临时货物需要装载，那么货车就会一直在装货，久久不能装载完毕。由此引发的弊端就是一些只有等待货物加载完毕之后才能做得事情，“被”延长了等待时间。



 ### Dom Tree ready 的时机 && 可人机交互的时机